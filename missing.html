
			opacity: 0.3 
		});

		// 建立第一片（向前傾斜）
		const n = 18; // 你想畫幾片就改這個數字
		const totalAngle = Math.PI; // 總展開角度 (Math.PI 是 180度，如果要一整圈就用 Math.PI * 2)

		const innerBoxes = [];

		// 建立 ShapeGeometry
		const shapeGeo = new THREE.ShapeGeometry(heartShape);
		shapeGeo.center(); 

		// 建立一個透明材質
		const innerMat = new THREE.MeshBasicMaterial({
			color: 0xffffff,
			side: THREE.DoubleSide,
			transparent: true,
			opacity: 0.3,      // 降低透明度，讓粒子更清晰
			depthWrite: false  // 關鍵：關閉深度寫入，這樣就不會遮擋內部的粒子
		});

		for (let i = 0; i < n; i++) {
			// 計算每一片的旋轉角度
			// 讓它們對稱展開：第一片和最後一片會分佈在 totalAngle 的兩端
			const angle = (i / (n - 1) - 0.5) * totalAngle;

			// 1. 建立線框 (LineLoop)
			const lineLoop = new THREE.LineLoop(geometry2D, lineMaterial);
			lineLoop.rotation.y = angle;
			lineLoop.rotation.y = angle;
			lineLoop.renderOrder = 10; // 優先級高
			cage.add(lineLoop);

			// 2. 建立填充面 (Mesh)
			const mesh = new THREE.Mesh(shapeGeo, innerMat);
			mesh.rotation.y = angle;
			mesh.scale.set(1.2, 1.2, 1.2);
			mesh.renderOrder = 1; // 優先級低
			cage.add(mesh);

			// 存入陣列方便之後操作
			innerBoxes.push(mesh);
		}

		scene.add(cage);
		window.cage = cage;
		window.innerBoxes = innerBoxes;
		
		cage.scale.set(1.2, 1.2, 1.2);
		
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 3;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        initialPositions = new Float32Array(particleCount * 3);

       for (let i = 0; i < particleCount; i++) {
			let i3 = i * 3;
			
			// 1. 取得隨機角度與填充比例
			const t = Math.random() * 2 * Math.PI;
			// 使用開根號讓粒子均勻分布在實心面積內，避免中心點過於密集
			const fill = Math.sqrt(Math.random()); 
			
			// 2. 愛心參數方程 (Heart Curve)
			let x = 16 * Math.pow(Math.sin(t), 3);
			let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
			
			// 3. 加上一點 Z 軸隨機深度，讓它有 3D 體感
			let z = (Math.random() - 0.5) * 8; 

			// 4. 設定縮放倍率 (符合你原本約 0.8 ~ 1.0 的空間大小)
			const scale = 0.05; 

			// 5. 賦值 (注意：這裡加了 -y 來修正你提到的上下顛倒問題)
			positions[i3] = x * scale * fill;
			positions[i3 + 1] = y * scale * fill; // 加負號轉正
			positions[i3 + 2] = z * scale * fill;

			// 6. 存入初始位置，這很重要，animate 函式會抓這裡的資料
			initialPositions[i3] = positions[i3];
			initialPositions[i3 + 1] = positions[i3 + 1];
			initialPositions[i3 + 2] = positions[i3 + 2];
		}

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        positionsArr = geometry.attributes.position.array;

        const material = new THREE.PointsMaterial({
			color: 0x000000,
			size: 0.02,              // 基礎大小
			map: createCircleTexture(), // 套用剛才畫的漸層貼圖
			transparent: true,
			opacity: 0.6,
			blending: THREE.NormalBlending,
			depthWrite: false,       // 關鍵：這能讓粒子重疊時不會有難看的方塊邊緣
			alphaTest: 0.001         // 確保透明部分的計算更精確
		});

        particleSystem = new THREE.Points(geometry, material);
		particleSystem.renderOrder = 10; // 較大的數字，後畫，保證看得到
        scene.add(particleSystem);

        window.addEventListener('resize', onWindowResize, false);
		syncSliders();
        animate();
    }

    async function initAudio() {
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('ui-layer').style.display = 'block';
		document.getElementById('mode-hint').style.display = 'block';
		document.getElementById('link').style.display = 'block';
		
		// --- 陀螺儀授權請求 (iOS 專用) ---
		if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
			try {
				const permission = await DeviceOrientationEvent.requestPermission();
				if (permission === 'granted') {
					window.addEventListener('deviceorientation', handleOrientation);
				}
			} catch (error) {
				console.error("陀螺儀授權失敗:", error);
			}
		} else {
			// 非 iOS 裝置（如 Android）通常不需要手動授權
			window.addEventListener('deviceorientation', handleOrientation);
		}

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audio = new Audio();
        audio.src = '相心.mp3'; 
        audio.crossOrigin = "anonymous";
        audio.loop = true;
        
        const source = audioContext.createMediaElementSource(audio);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        source.connect(analyser);
        analyser.connect(audioContext.destination);

        dataArray = new Uint8Array(analyser.frequencyBinCount);
        if (audioContext.state === 'suspended') await audioContext.resume();
        audio.play();
    }
	
	// 處理陀螺儀數據
	function handleOrientation(event) {
		let x = event.gamma || 0; // 左右 (-90 到 90)
		let y = event.beta || 0;  // 前後 (-180 到 180)

		// 第一筆數據進來時，紀錄為基準點
		if (baseGamma === null) baseGamma = x;
		if (baseBeta === null) baseBeta = y;

		// 計算偏移量 (當前角度 - 基準角度)
		// 我們限制偏移量在一個合理範圍內
		gyroX = Math.max(Math.min((x - baseGamma) / 20, 1.5), -1.5);
		gyroY = Math.max(Math.min((y - baseBeta) / 20, 1.5), -1.5);
	}

    function animate() {
        requestAnimationFrame(animate);
        time += params.speed * 100;

        if (analyser) {
            analyser.getByteFrequencyData(dataArray);
			
			audioMappings.forEach(mapping => {
				const el = mapping.el;
				if (el.dataset.isDragging === "true") return;

				// 1. 計算平均值
				let sum = 0;
				for (let i = mapping.range[0]; i <= mapping.range[1]; i++) {
					sum += dataArray[i];
				}
				let currentAvg = sum / (mapping.range[1] - mapping.range[0] + 1);

				// 2. 強化：扣除底噪門檻 (讓數值更有「空間」呼吸)
				const noiseFloor = 30; 
				currentAvg = Math.max(0, currentAvg - noiseFloor);

				// 3. 強化：動態峰值 (快速上升，極慢下降)
				if (currentAvg > mapping.peak) {
					// 即使聲音變大，也不要立刻更新 peak，用一點緩衝
					mapping.peak += (currentAvg - mapping.peak) * 0.2; 
				} else {
					mapping.peak *= 0.99999; // 維持在一個適中的下降速度
				}

				// 4. 【核心關鍵】：非線性縮放 (加上 Power 函數)
				// 透過 Math.pow(ratio, 2)，小聲音會更小，大聲音才有爆發感
				let ratio = currentAvg / (Math.max(mapping.peak, 50));
				ratio = Math.pow(ratio, 1.5); // 數值越大，Slider 越難衝到頂 (1.5 ~ 2.0 效果最佳)

				// 5. 映射與 Lerp
				const min = parseFloat(el.min);
				const max = parseFloat(el.max);
				const targetVal = min + (max - min) * ratio;

				// 降低靈敏度 (從 0.1 降到 0.05)，增加絲滑感
				params[mapping.key] += (targetVal - params[mapping.key]) * 0.1;
				
				el.value = params[mapping.key];
			});
			
            let sum = 0;
            for (let j = 0; j < dataArray.length; j++) sum += dataArray[j];
            const boost = (sum / dataArray.length) / 255;

            const posAttribute = particleSystem.geometry.attributes.position;
            const freqLen = dataArray.length;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const freqVal = dataArray[i % freqLen] / 255.0;
                const noise = Math.sin(initialPositions[i3] * params.frequency + time) * params.intensity;
                const scale = 1.0 + (freqVal * 3.0) + (boost * 1.0);

                // 在 animate 迴圈內
				let posX = initialPositions[i3] * scale + noise;
				let posY = initialPositions[i3+1] * scale + noise;
				let posZ = initialPositions[i3+2] * scale + noise;

				const limit = 1.0;
				const radisSquared = limit*limit;
				const distanceSquared = Math.abs(posX)*Math.abs(posX)+Math.abs(posY)*Math.abs(posY)+Math.abs(posZ)*Math.abs(posZ);
				// 如果超過邊界，增加一個震盪阻力
				if (distanceSquared>radisSquared)
				{
					posX *= 0.2;
					posY *= 0.2;
					posZ *= 0.2;
				}

				positionsArr[i3] = posX;
				positionsArr[i3+1] = posY;
				positionsArr[i3+2] = posZ;
            }
            posAttribute.needsUpdate = true;
            
			// --- 核心修改：視角偏移效果 ---
			// 1. 設定目標位置 (Z 軸維持在 3，XY 軸隨陀螺儀偏移)
			const targetCamX = gyroX * 1.2; 
			const targetCamY = -gyroY * 1.2; // 這裡是負號，讓手機往上抬時視角往下看，產生視差

			// 2. 絲滑移動 (Lerp): 當前位置 + (目標 - 當前) * 係數
			camera.position.x += (targetCamX - camera.position.x) * 0.08;
			camera.position.y += (targetCamY - camera.position.y) * 0.08;

			// 3. 永遠盯著中心點，這會產生強烈的立體透視感
			camera.lookAt(0, 0, 0);
			
            particleSystem.rotation.y += - (gyroX * 0.05); // 隨左右傾斜加速旋轉
			//particleSystem.rotation.x += 0.001 - (gyroY * 0.05); // 隨前後傾斜加速旋轉

            // 1. 設定一個觸發門檻 (例如 0.4，你可以根據音樂調整)
			const boostThreshold = 0.32; 
			// 只計算超過門檻的部分，並放大它的倍率
			let activeBoost = Math.max(0, boost - boostThreshold) * 2.0;

			// 2. 更新視覺衝擊變數
			if (activeBoost > visualBoost) {
				visualBoost = activeBoost; // 瞬間衝高
			} else {
				visualBoost *= 0.85; // 稍微加快回歸速度，讓閃爍更俐落
			}

			// 3. 只有當 visualBoost 真的有值時才改變顏色與縮放
			if (visualBoost > 0.01) {
				const colorIntensity = 1.0 - (visualBoost * 0.4);
				const s = 1.2 + (visualBoost * 0.05);
				const op = 0.3 + (visualBoost * 0.6);

				// 處理內壁：用 forEach 同時更新兩片心形的顏色
				innerBoxes.forEach(box => {
					box.material.color.setRGB(colorIntensity, colorIntensity, colorIntensity);
				});

				// 處理外框：因為 cage 是 Group，要遍歷它的子物件（LineLoop）來改透明度
				cage.scale.set(s, s, s);
				cage.children.forEach(child => {
					if (child.material) child.material.opacity = op;
				});

			} else {
				// 平時回歸初始狀態
				innerBoxes.forEach(box => {
					box.material.color.setRGB(1, 1, 1);
				});

				cage.scale.set(1.2, 1.2, 1.2);
				cage.children.forEach(child => {
					if (child.material) child.material.opacity = 0.3;
				});
			}
        } else {
            particleSystem.rotation.y += 0.002;
			//particleSystem.rotation.x += 0.001;
        }
        renderer.render(scene, camera);
    }
	
	function createCircleTexture() {
		const canvas = document.createElement('canvas');
		canvas.width = 64;
		canvas.height = 64;
		const ctx = canvas.getContext('2d');

		// 徑向漸層：中心不透明，邊緣完全透明
		const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
		gradient.addColorStop(0, 'rgba(0,0,0,1)');   // 中心純黑
		gradient.addColorStop(0.2, 'rgba(0,0,0,0.5)'); // 中間過渡
		gradient.addColorStop(1, 'rgba(0,0,0,0)');   // 邊緣消失

		ctx.fillStyle = gradient;
		ctx.fillRect(0, 0, 64, 64);

		const texture = new THREE.CanvasTexture(canvas);
		return texture;
	}

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
</script>
</body>
</html>
